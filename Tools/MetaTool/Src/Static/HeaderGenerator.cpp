//
// Created by johnk on 2022/5/25.
//

#include <MetaTool/HeaderGenerator.h>
#include <MetaTool/ClangParser.h>
#include <Common/Debug.h>

namespace MetaTool {
    template <typename T>
    std::string GetContextFullName(const std::string& prefix, const T& context)
    {
        return prefix.empty() ? context.name : (prefix + "::" + context.name);
    }
}

namespace MetaTool {
    HeaderGenerator::HeaderGenerator(const HeaderGeneratorInfo& info)
        : info(info), file(info.outputFilePath)
    {
        Assert(file.is_open());
    }

    HeaderGenerator::~HeaderGenerator()
    {
        file.close();
    }

    void HeaderGenerator::Generate(const MetaContext& metaInfo)
    {
        GenerateFileHeader();
        GenerateIncludes();
        GenerateRegistry(metaInfo);
    }

    void HeaderGenerator::GenerateFileHeader()
    {
        file << "/**" << std::endl;
        file << " * Generated by Explosion header generater, do not modify this file anyway." << std::endl;
        file << " */" << std::endl;
        file << std::endl;
        file << "#pragma once" << std::endl;
        file << std::endl;
    }

    void HeaderGenerator::GenerateIncludes()
    {
        file << "#include <string_view>" << std::endl;
        file << std::endl;
        file << "#include <meta/factory.hpp>" << std::endl;
        file << std::endl;
        file << "#include <" << info.sourceFileShortPath << ">" << std::endl;
        file << std::endl;
    }

    void HeaderGenerator::GenerateRegistry(const MetaTool::MetaContext& metaInfo)
    {
        file << "static int _registry = []() -> int {" << std::endl;
        file << "    std::hash<std::string_view> hash {};" << std::endl;
        GenerateMetaCodeForNamespace(metaInfo.name, metaInfo);
        file << "}();" << std::endl;
        file << std::endl;
    }

    void HeaderGenerator::GenerateMetaCodeForNamespace(const std::string& prefix, const MetaTool::NamespaceContext& namespaceContext)
    {
        std::string fullName = GetContextFullName(prefix, namespaceContext);
        for (const auto& n : namespaceContext.namespaces) {
            GenerateMetaCodeForNamespace(fullName, n);
        }
        for (const auto& c : namespaceContext.classes) {
            GenerateMetaCodeForClasses(fullName, c);
        }
    }

    void HeaderGenerator::GenerateMetaCodeForClasses(const std::string& prefix, const MetaTool::ClassContext& classContext)
    {
        std::string fullName = GetContextFullName(prefix, classContext);
        file << "    meta::reflect<" << fullName << ">(hash(\"" << fullName << "\")" << std::endl;
        for (const auto& v : classContext.variables) {
            GenerateMetaCodeForProperty(fullName, v);
        }
        for (const auto& f : classContext.functions) {
            GenerateMetaCodeForFunction(fullName, f);
        }
        file << "    ;" << std::endl;
    }

    void HeaderGenerator::GenerateMetaCodeForProperty(const std::string& prefix, const VariableContext& variableContext)
    {
        std::string fullName = GetContextFullName(prefix, variableContext);
        file << "        .data<&" << fullName << ">(hash(\"" << fullName << "\")" << std::endl;
    }

    void HeaderGenerator::GenerateMetaCodeForFunction(const std::string& prefix, const FunctionContext& functionContext)
    {
        std::string fullName = GetContextFullName(prefix, functionContext);
        file << "        .func<&" << fullName << ">(hash(\"" << fullName << "\")" << std::endl;
    }
}
